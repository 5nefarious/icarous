// -*- Mode: C++ -*-
// Simple conflict detection strategy

Integer Lookup numMissionWP;
Real[3] Lookup position;
Real[3] Lookup velocity;

Real[3] Command GetWaypoint(String planID,Integer index);
Boolean[2] Command CheckFenceViolation(Real Position[3],Real Velocity[3]);
Real[3] Command GetRecoveryPosition(Real Position[3]);
Command pprint(...);

// Library plans
LibraryAction GOTO_POSITION (In Real CurrentPos[3],In Real CurrentVel[3],In Real TargetPosition[3]);

CONFLICT_MANAGEMENT:
{
    Integer _numMissionWP;
    Real acPosition[3];
    Real acVelocity[3];
    Boolean fenceConflict[2] = #(false false);
    Boolean trafficConflict = false;
    Boolean flightPlanConflict = false;
    Boolean resolutionActive = false;
    Real newConflictHash = 0;
    Real oldConflictHash = 0;
    Integer _currentM_WP = 0;
    Integer _currentR_WP = 0;
    
    EndCondition (_currentM_WP >= Lookup(numMissionWP));

    _numMissionWP = Lookup(numMissionWP);

    pprint("starting CONFLICT_MANAGEMENT");

    pprint(_numMissionWP);

    CORE:Concurrence
    {
	
        DETECTION:
        {
            InOut Boolean fenceConflict[2];
            Integer numFenceConflicts;
            Boolean statusGF[2];
            Boolean statusTF;
            Boolean statusFP;

            Repeat true;

            acPosition = Lookup(position);
            acVelocity = Lookup(velocity);

            FENCE:
            {
                EndCondition isKnown(statusGF[0]);
                statusGF = CheckFenceViolation(acPosition,acVelocity);
            }

            //pprint("conflict:",statusGF[0],statusGF[1]);

            /*
              TRAFFIC:{
              EndCondition isKnown(statusTF);
              statusTF = CheckTrafficViolation(acPosition);
              }

              FLIGHTPLAN: {
              EndCondition isKnown(statusFP);
              if(resolutionActive){
              _currentR_WP = Lookup(currentResolutionWP);
              statusFP = CheckFlightPlanConflict(acPosition,_currentR_WP);
              }
              else{
              _currentM_WP = Lookup(currentMissionWP)
              statusFP = CheckFlightPlanConflict(acPosition,_currentM_WP);
              }
              endif
              }*/

            fenceConflict[0] = statusGF[0];
            fenceConflict[1] = statusGF[1];
            //trafficConflict = statusTF;
            //flightPlanConflict = statusFP;

            if(fenceConflict[0] || fenceConflict[1]){
            //pprint("Detected geofence conflict\n");
            }endif
        }


        RESOLUTION:{
            InOut Boolean fenceConflict[2];
            Real RecoveryPosition[3];
            Boolean resolutionCompleted = false;
            Repeat true;

            COMPUTE_SOLUTION:{

                KEEP_IN:{
                    StartCondition fenceConflict[0];

                    pprint("Obtaining recovery point");

                    {
                        EndCondition isKnown(RecoveryPosition[0]);
                        RecoveryPosition = GetRecoveryPosition(acPosition);
                    }

                    pprint("RecoveryPosition:",RecoveryPosition[0],RecoveryPosition[1],RecoveryPosition[2]);

                }

                /*
                  KEEP_OUT:{
                  SkipCondition !fenceConflict[1];

                  }

                  TRAFFIC:{


                  }

                  FLIGHTPLAN_DEV:{


                  }
                     */
            }

            EXECUTE_RESOLUTION:{
                FENCE_RESOLUTION:{
                    SkipCondition !fenceConflict[0];
                    LibraryCall GOTO_POSITION(TargetPosition = RecoveryPosition);
                }
            }

            RESUME_MISSION:{
                Boolean validPoint = false;
                SkipCondition !resolutionCompleted;

                while(!validPoint && _currentM_WP < _numMissionWP){
                    Real _position[3];
                    Real _velocity[3];
                    Boolean status[2];

                    _velocity[0] = 0.0;
                    _velocity[1] = 0.0;
                    _velocity[2] = 0.0;

                    {
                        EndCondition isKnown(_position);
                        _position = GetWaypoint("Plan1",_currentM_WP);
                    }

                    {
                        EndCondition isKnown(status[0]);
                        status = CheckFenceViolation(_position,_velocity);
                    }

                    if(status[0] || status[1]){
                        _currentM_WP = _currentM_WP + 1;
                    }else{
                        validPoint = true;
                        LibraryCall GOTO_POSITION(TargetPosition = _position);
                    }endif

                }
            }

        }
	}
}
