// -*- Mode: C++ -*-
// Simple conflict detection strategy

Integer Lookup numMissionWP;
Integer Lookup nextMissionWPIndex;
Real[3] Lookup position;
Real[3] Lookup velocity;

Real[3] Command GetWaypoint(String planID,Integer index);
Boolean[2] Command CheckFenceViolation(Real Position[3],Real Velocity[3]);
Real[3] Command GetRecoveryPosition(Real Position[3]);
Real[3] Command GetExitPoint(String planID,Real Position[3],Integer nextWP);
Real[4] Command MonitorTraffic(Real position[3],Real velocity[3]);
Command SetMode(String mode);
Command SetNextMissionWP(Integer index);
Command SetVel(Real velocity[3]);
Real Command GetInterceptHeadingToPlan(String planID,Integer leg,Real position[3]);
Boolean Command CheckSafeToTurn(Real position[3],Real velocity[3],Real fromHeading,Real toHeading);
Command pprint(...);

// Library plans
LibraryAction GOTO_POSITION (In Real TargetPosition[3],InOut Boolean resolutionCompleted);

CONFLICT_MANAGEMENT:
{
    Integer _numMissionWP;
    Real acPosition[3];
    Real acVelocity[3];
    Boolean fenceConflict[2] = #(false false);
    Boolean trafficConflict = false;
    Boolean flightPlanConflict = false;
    Boolean resolutionActive = false;
    Real newConflictHash = 0;
    Real oldConflictHash = 0;
    Integer _currentM_WP = 1;
    Integer _currentR_WP = 0;
    
    EndCondition (_currentM_WP >= Lookup(numMissionWP));

    _numMissionWP = Lookup(numMissionWP);

    pprint("starting CONFLICT_MANAGEMENT");

    pprint(_numMissionWP);

    CORE:Concurrence
    {
	
        DETECTION:
        {
            InOut Boolean fenceConflict[2];
            Integer numFenceConflicts;
            Boolean statusGF[2];
            Boolean statusTF;
            Boolean statusFP;

            Repeat true;

            acPosition = Lookup(position);
            acVelocity = Lookup(velocity);

            FENCE:
            {
                EndCondition isKnown(statusGF[0]);
                statusGF = CheckFenceViolation(acPosition,acVelocity);
            }

            //pprint("conflict:",statusGF[0],statusGF[1]);

            TRAFFIC:{

                Real tfOutput[4];
                {
                    EndCondition isKnown(tfOutput[0]);
                    tfOutput = MonitorTraffic(acPosition,acVelocity);
                }

                if(tfOutput[0] > 0){
                    statusTF = true;
                    //pprint("traffic conflict");
                }else{
                    statusTF = false;
                }endif
            }

              /*
              FLIGHTPLAN: {
              EndCondition isKnown(statusFP);
              if(resolutionActive){
              _currentR_WP = Lookup(currentResolutionWP);
              statusFP = CheckFlightPlanConflict(acPosition,_currentR_WP);
              }
              else{
              _currentM_WP = Lookup(currentMissionWP)
              statusFP = CheckFlightPlanConflict(acPosition,_currentM_WP);
              }
              endif
              }*/

            fenceConflict[0] = statusGF[0];
            fenceConflict[1] = statusGF[1];
            trafficConflict = statusTF;
            //flightPlanConflict = statusFP;

            if(fenceConflict[0] || fenceConflict[1]){
               //pprint("Detected geofence conflict\n");
            }endif
        }


        RESOLUTION:{
            InOut Boolean fenceConflict[2];
            InOut Boolean trafficConflict;
            Real RecoveryPosition[3];
            Boolean resolutionStatus = false;
            Repeat true;

            COMPUTE_SOLUTION:{
                StartCondition (fenceConflict[0] || fenceConflict[1] || trafficConflict);
                _currentM_WP = Lookup(nextMissionWPIndex);

                KEEP_IN:{
                    SkipCondition !fenceConflict[0];

                    pprint("Obtaining recovery point");

                    {
                        EndCondition isKnown(RecoveryPosition[0]);
                        RecoveryPosition = GetRecoveryPosition(acPosition);
                    }

                    pprint("RecoveryPosition:",RecoveryPosition[0],RecoveryPosition[1],RecoveryPosition[2]);

                }


                KEEP_OUT:{
                    SkipCondition !fenceConflict[1];

                    pprint("Obtaining exit point");

                    {
                       EndCondition isKnown(RecoveryPosition[0]);
                       RecoveryPosition = GetExitPoint("Plan0",acPosition,_currentM_WP);
                    }

                    pprint("RecoveryPosition:",RecoveryPosition[0],RecoveryPosition[1],RecoveryPosition[2]);
                }

            }

            EXECUTE_RESOLUTION:{
                FENCE_RESOLUTION:{
                    Boolean _resolutionCompleted;
                    SkipCondition (!fenceConflict[0] && !fenceConflict[1]);
                    LibraryCall GOTO_POSITION(TargetPosition = RecoveryPosition,
                                              resolutionCompleted = _resolutionCompleted);
                    resolutionStatus = _resolutionCompleted;
                }

                TRAFFIC_RESOLUTION:{
                   Real prevVelCmd[3];
                   SkipCondition !trafficConflict;
                   EndCondition resolutionStatus;

                   //acPosition = Lookup(position);
                   //acVelocity = Lookup(velocity);

                   SetMode("ACTIVE");

                   {
                     Real output[4];
                     Real velCmd[3];
                     Real returnVel[3];
                     Boolean returnSafe;
                     Real track;
                     Real speed;
                     Repeat true;

                     {
                         EndCondition isKnown(output[0]);
                         output = MonitorTraffic(acPosition,acVelocity);
                     }

                     pprint("output traffic resolution:",output);

                     if(output[1] < 100)
                        velCmd[0] = output[1];
                     else
                        velCmd[0] = prevVelCmd[0];
                     endif
                     velCmd[1] = 1;
                     velCmd[2] = 0;

                     SetVel(velCmd);

                     prevVelCmd[0] = velCmd[0];
                     prevVelCmd[1] = velCmd[1];
                     prevVelCmd[2] = velCmd[2];

                     {
                         EndCondition isKnown(track);
                         track = GetInterceptHeadingToPlan("Plan0",_currentM_WP,acPosition);
                     }

                     pprint("Intercept heading:",track);

                     returnVel[0] = track;
                     returnVel[1] = 1;
                     returnVel[2] = 0;

                     {
                          EndCondition isKnown(returnSafe);
                          returnSafe = CheckSafeToTurn(acPosition,acVelocity,velCmd[0],returnVel[0]);
                     }

                     pprint("return safe:",returnSafe);

                     if(returnSafe && output[0] < 0){
                           resolutionStatus = true;
                     }endif

                   }
                }

                pprint("Resolution status:",resolutionStatus);
            }

            RESUME_MISSION:{
                Boolean validPoint = false;
                SkipCondition !resolutionStatus;

                pprint("Resuming mission");

                while(!validPoint && _currentM_WP < _numMissionWP){
                    Real _position[3];
                    Real _velocity[3];
                    Boolean status[2];

                    _velocity[0] = 0.0;
                    _velocity[1] = 0.0;
                    _velocity[2] = 0.0;

                    {
                        EndCondition isKnown(_position[0]);
                        _position = GetWaypoint("Plan0",_currentM_WP);
                    }

                    pprint("Obtained waypoint with index:",_currentM_WP);
                    pprint("Checking fence violation of WP:",_position[0],_position[1]);

                    {
                        EndCondition isKnown(status[0]);
                        status = CheckFenceViolation(_position,_velocity);
                    }

                    pprint("status:",status[0],status[1]);

                    if(status[0] || status[1]){
                        _currentM_WP = _currentM_WP + 1;
                        pprint("incrementing index:");
                    }else{
                        Boolean _resolutionCompleted;
                        validPoint = true;
                        pprint("Going to next waypoint");
                        LibraryCall GOTO_POSITION(TargetPosition = _position,
                                                  resolutionCompleted = _resolutionCompleted);

                        _currentM_WP = _currentM_WP + 1;
                        SetNextMissionWP(_currentM_WP);
                        SetMode("PASSIVE");
                    }endif

                }
            }

        }
	}
}
