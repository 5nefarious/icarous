// -*- Mode: C++ -*-
// Simple conflict detection strategy

Integer Lookup numMissionWP;
Integer Lookup nextMissionWPIndex;
Real[3] Lookup position;
Real[3] Lookup velocity;

Real[3] Command GetWaypoint(String planID,Integer index);
Boolean[2] Command CheckFenceViolation(Real Position[3],Real Velocity[3]);
Real[3] Command GetRecoveryPosition(Real Position[3]);
Command SetMode(String mode);
Command SetNextMissionWP(Integer index);
Command pprint(...);
Real[3] Command GetExitPoint(String planID,Real Position[3],Integer nextWP);

// Library plans
LibraryAction GOTO_POSITION (In Real TargetPosition[3],InOut Boolean resolutionCompleted);

CONFLICT_MANAGEMENT:
{
    Integer _numMissionWP;
    Real acPosition[3];
    Real acVelocity[3];
    Boolean fenceConflict[2] = #(false false);
    Boolean trafficConflict = false;
    Boolean flightPlanConflict = false;
    Boolean resolutionActive = false;
    Real newConflictHash = 0;
    Real oldConflictHash = 0;
    Integer _currentM_WP = 1;
    Integer _currentR_WP = 0;
    String currentPlanID = "Plan0"
    
    EndCondition (_currentM_WP >= Lookup(numMissionWP));

    _numMissionWP = Lookup(numMissionWP);

    pprint("starting CONFLICT_MANAGEMENT");

    pprint(_numMissionWP);

    CORE:Concurrence
    {
	
        DETECTION:
        {
            InOut Boolean fenceConflict[2];
            Integer numFenceConflicts;
            Boolean statusGF[2];
            Boolean statusTF;
            Boolean statusFP;

            Repeat true;

            acPosition = Lookup(position);
            acVelocity = Lookup(velocity);

            FENCE:
            {
                EndCondition isKnown(statusGF[0]);
                statusGF = CheckFenceViolation(acPosition,acVelocity);
            }

            //pprint("conflict:",statusGF[0],statusGF[1]);

            /*
              TRAFFIC:{
              EndCondition isKnown(statusTF);
              statusTF = CheckTrafficViolation(acPosition);
              }

              FLIGHTPLAN: {
              EndCondition isKnown(statusFP);
              if(resolutionActive){
              _currentR_WP = Lookup(currentResolutionWP);
              statusFP = CheckFlightPlanConflict(acPosition,_currentR_WP);
              }
              else{
              _currentM_WP = Lookup(currentMissionWP)
              statusFP = CheckFlightPlanConflict(acPosition,_currentM_WP);
              }
              endif
              }*/

            fenceConflict[0] = statusGF[0];
            fenceConflict[1] = statusGF[1];
            //trafficConflict = statusTF;
            //flightPlanConflict = statusFP;

            if(fenceConflict[0] || fenceConflict[1]){
            //pprint("Detected geofence conflict\n");
            }endif
        }


        RESOLUTION:{
            InOut Boolean fenceConflict[2];
            Real RecoveryPosition[3];
            Boolean resolutionStatus = false;
            Repeat true;

            COMPUTE_SOLUTION:{

                _currentM_WP = Lookup(nextMissionWPIndex);

                KEEP_IN:{
                    SkipCondition !fenceConflict[0];

                    pprint("Obtaining recovery point");

                    {
                        EndCondition isKnown(RecoveryPosition[0]);
                        RecoveryPosition = GetRecoveryPosition(acPosition);
                    }

                    pprint("RecoveryPosition:",RecoveryPosition[0],RecoveryPosition[1],RecoveryPosition[2]);

                }


                KEEP_OUT:{
                    Real exitPosition[3]
                    SkipCondition !fenceConflict[1];

                    {
                        EndCondition isKnown(exitPosition[0]);
                        exitPosition = GetExitPoint(currentPlanID,acPosition,_currentM_WP);

                    }



                }

                  /*
                  TRAFFIC:{


                  }

                  FLIGHTPLAN_DEV:{


                  }
                     */
            }

            EXECUTE_RESOLUTION:{
                FENCE_RESOLUTION:{
                    Boolean _resolutionCompleted;
                    SkipCondition !fenceConflict[0];
                    LibraryCall GOTO_POSITION(TargetPosition = RecoveryPosition,
                                              resolutionCompleted = _resolutionCompleted);
                    resolutionStatus = _resolutionCompleted;
                }

                //pprint("Resolution status:",resolutionStatus);
            }

            RESUME_MISSION:{
                Boolean validPoint = false;
                SkipCondition !resolutionStatus;

                pprint("Resuming mission");

                while(!validPoint && _currentM_WP < _numMissionWP){
                    Real _position[3];
                    Real _velocity[3];
                    Boolean status[2];

                    _velocity[0] = 0.0;
                    _velocity[1] = 0.0;
                    _velocity[2] = 0.0;

                    {
                        EndCondition isKnown(_position[0]);
                        _position = GetWaypoint("Plan0",_currentM_WP);
                    }

                    pprint("Obtained waypoint with index:",_currentM_WP);
                    pprint("Checking fence violation of WP:",_position[0],_position[1]);

                    {
                        EndCondition isKnown(status[0]);
                        status = CheckFenceViolation(_position,_velocity);
                    }

                    pprint("status:",status[0],status[1]);

                    if(status[0] || status[1]){
                        _currentM_WP = _currentM_WP + 1;
                        pprint("incrementing index:");
                    }else{
                        Boolean _resolutionCompleted;
                        validPoint = true;
                        pprint("Going to next waypoint");
                        LibraryCall GOTO_POSITION(TargetPosition = _position,
                                                  resolutionCompleted = _resolutionCompleted);

                        _currentM_WP = _currentM_WP + 1;
                        SetNextMissionWP(_currentM_WP);
                        SetMode("PASSIVE");
                        currentPlanID = "Plan0"
                    }endif

                }
            }

        }
	}
}
