// -*- Mode: C++ -*-
// Simple conflict detection strategy

// Lookup definitions
Integer Lookup numMissionWP;
Integer Lookup nextMissionWPIndex;
Real[3] Lookup position;
Real[3] Lookup velocity;
Real    Lookup allowedXtrackDev;

// Command definitions
Real[3]    Command GetWaypoint(String planID,Integer index);
Boolean[2] Command CheckFenceViolation(Real Position[3],Real Velocity[3]);
Real       Command ComputeCrossTrackDeviation(String planID,Integer leg,Real position[3]);
Real[3]    Command GetRecoveryPosition(Real Position[3]);
Real[3]    Command GetExitPoint(String planID,Real Position[3],Integer nextWP);
Real[4]    Command MonitorTraffic(Real position[3],Real velocity[3]);
Real       Command GetInterceptHeadingToPlan(String planID,Integer leg,Real position[3]);
Real[3]    Command ManeuverToIntercept(String planID,Integer leg,Real position[3]);
Boolean    Command CheckSafeToTurn(Real position[3],Real velocity[3],Real fromHeading,Real toHeading);

Command SetMode(String mode);
Command SetNextMissionWP(Integer index);
Command SetVel(Real velocity[3]);
Command pprint(...);

// Library plans
LibraryAction GOTO_POSITION (In Real TargetPosition[3],InOut Boolean resolutionCompleted);

CONFLICT_MANAGEMENT:
{
    Integer _numMissionWP;
    Real acPosition[3];
    Real acVelocity[3];
    Boolean keepInConflict = false;
    Boolean keepOutConflict = false;
    Boolean trafficConflict = false;
    Boolean flightPlanConflict = false;
    Boolean resolutionActive = false;
    Real newConflictHash = 0;
    Real oldConflictHash = 0;
    Real allowedDeviation;
    Real deviation;
    Integer _currentM_WP = 1;
    Integer _currentR_WP = 0;
    
    EndCondition (_currentM_WP >= Lookup(numMissionWP));

    _numMissionWP = Lookup(numMissionWP);
    allowedDeviation = Lookup(allowedXtrackDev);

    pprint("starting CONFLICT_MANAGEMENT");

    pprint(_numMissionWP);

    CORE:Concurrence
    {
	
        DETECTION:
        {
            InOut Boolean keepInConflict;
            InOut Boolean keepOutConflict;
            Integer numFenceConflicts;
            Boolean statusGF[2];
            Boolean statusTF;
            Boolean statusFP;

            Repeat true;

            acPosition = Lookup(position);
            acVelocity = Lookup(velocity);

            FENCE:
            {
                EndCondition isKnown(statusGF[0]);
                statusGF = CheckFenceViolation(acPosition,acVelocity);
            }

            //pprint("conflict:",statusGF[0],statusGF[1]);

            TRAFFIC:{

                Real tfOutput[4];
                {
                    EndCondition isKnown(tfOutput[0]);
                    tfOutput = MonitorTraffic(acPosition,acVelocity);
                }

                if(tfOutput[0] > 0){
                    statusTF = true;
                    //pprint("traffic conflict");
                }else{
                    statusTF = false;
                }endif
            }


            FLIGHTPLAN: {
                  Integer nextWP;
                  Real _deviation;
                  EndCondition isKnown(statusFP);

                  nextWP = Lookup(nextMissionWPIndex);
                  {
                    EndCondition isKnown(_deviation);
                    _deviation = ComputeCrossTrackDeviation("Plan0",nextWP,acPosition);
                  }

                  deviation = _deviation;

                  if(!resolutionActive){
                      if (deviation > allowedDeviation){
                          statusFP = true;
                      }else{
                          statusFP = false;
                      }endif
                  }else{
                      statusFP = false;
                  }endif
            }

            keepInConflict = statusGF[0];
            keepOutConflict = statusGF[1];
            trafficConflict = statusTF;
            flightPlanConflict = statusFP;
        }


        RESOLUTION:{
            In Boolean keepInConflict;
            In Boolean keepOutConflict;
            In Boolean trafficConflict;
            In Boolean flightPlanConflict;
            Real RecoveryPosition[3];
            Boolean completionStatus = false;
            StartCondition (keepInConflict || keepOutConflict || trafficConflict || flightPlanConflict );
            Repeat true;

            resolutionActive = true;

            pprint("Starting resolution");

            GET_RECOVERY_POSITION:{

                _currentM_WP = Lookup(nextMissionWPIndex);

                KEEP_IN:{
                    SkipCondition !keepInConflict;

                    pprint("Obtaining recovery point");

                    {
                        EndCondition isKnown(RecoveryPosition[0]);
                        RecoveryPosition = GetRecoveryPosition(acPosition);
                    }

                    pprint("RecoveryPosition:",RecoveryPosition[0],RecoveryPosition[1],RecoveryPosition[2]);

                }


                KEEP_OUT:{
                    SkipCondition !keepOutConflict;

                    pprint("Obtaining exit point");

                    {
                       EndCondition isKnown(RecoveryPosition[0]);
                       RecoveryPosition = GetExitPoint("Plan0",acPosition,_currentM_WP);
                    }

                    pprint("RecoveryPosition:",RecoveryPosition[0],RecoveryPosition[1],RecoveryPosition[2]);
                }

            }

            EXECUTE_RESOLUTION:{
                FENCE_RESOLUTION:{
                    Boolean _resolutionCompleted;
                    SkipCondition (!keepInConflict && !keepOutConflict);

                    LibraryCall GOTO_POSITION(TargetPosition = RecoveryPosition,
                                              resolutionCompleted = _resolutionCompleted);
                    completionStatus = _resolutionCompleted;
                }

                TRAFFIC_RESOLUTION:{
                   Real prevVelCmd[3];
                   SkipCondition !trafficConflict;
                   EndCondition completionStatus;

                   SetMode("ACTIVE");

                   {
                     Real output[4];
                     Real velCmd[3];
                     Real returnVel[3];
                     Boolean returnSafe;
                     Real track;
                     Real speed;
                     Repeat true;

                     {
                         EndCondition isKnown(output[0]);
                         output = MonitorTraffic(acPosition,acVelocity);
                     }

                     pprint("output traffic resolution:",output);

                     if(output[1] < 100)
                        velCmd[0] = output[1];
                     else
                        velCmd[0] = prevVelCmd[0];
                     endif
                     velCmd[1] = 1;
                     velCmd[2] = 0;

                     SetVel(velCmd);

                     prevVelCmd[0] = velCmd[0];
                     prevVelCmd[1] = velCmd[1];
                     prevVelCmd[2] = velCmd[2];

                     {
                         EndCondition isKnown(track);
                         track = GetInterceptHeadingToPlan("Plan0",_currentM_WP,acPosition);
                     }

                     pprint("Intercept heading:",track);

                     returnVel[0] = track;
                     returnVel[1] = 1;
                     returnVel[2] = 0;

                     {
                          EndCondition isKnown(returnSafe);
                          returnSafe = CheckSafeToTurn(acPosition,acVelocity,velCmd[0],returnVel[0]);
                     }

                     pprint("return safe:",returnSafe);

                     if(returnSafe && output[0] < 0){
                           completionStatus = true;
                     }endif

                   }
                }

                FLIGHTPLAN:{

                    SkipCondition !flightPlanConflict;
                    EndCondition (deviation < allowedDeviation/2);

                    completionStatus = true;

                    pprint("Executing flight plan resolution");

                    SetMode("ACTIVE");

                    MANEUVER:
                    {
                        Real velCmd[3];
                        Repeat true;

                        COMPUTE_VELOCITY:
                        {
                           EndCondition isKnown(velCmd[0]);
                           velCmd = ManeuverToIntercept("Plan0",_currentM_WP,acPosition);
                        }

                        SetVel(velCmd);
                    }

                }

                pprint("Resolution status:",completionStatus);
            }

            RESUME_MISSION:{
                Boolean validPoint = false;
                SkipCondition !completionStatus;

                pprint("Resuming mission");

                while(!validPoint && _currentM_WP < _numMissionWP){
                    Real _position[3];
                    Real _velocity[3];
                    Boolean status[2];

                    _velocity[0] = 0.0;
                    _velocity[1] = 0.0;
                    _velocity[2] = 0.0;

                    {
                        EndCondition isKnown(_position[0]);
                        _position = GetWaypoint("Plan0",_currentM_WP);
                    }

                    pprint("Obtained waypoint with index:",_currentM_WP);
                    pprint("Checking fence violation of WP:",_position[0],_position[1]);

                    {
                        EndCondition isKnown(status[0]);
                        status = CheckFenceViolation(_position,_velocity);
                    }

                    pprint("status:",status[0],status[1]);

                    if(status[0] || status[1]){
                        _currentM_WP = _currentM_WP + 1;
                        pprint("incrementing index:");
                    }else{
                        Boolean _resolutionCompleted;
                        validPoint = true;
                        pprint("Going to next waypoint");
                        LibraryCall GOTO_POSITION(TargetPosition = _position,
                                                  resolutionCompleted = _resolutionCompleted);

                        _currentM_WP = _currentM_WP + 1;
                        SetNextMissionWP(_currentM_WP);
                        SetMode("PASSIVE");
                        resolutionActive = false;
                    }endif

                }
            }

        }
	}
}
