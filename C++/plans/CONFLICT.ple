// -*- Mode: Java -*-
// Simple conflict detection strategy

Integer Lookup numMissionWP;
Real[3] Lookup position;
Real[3] Lookup velocity;

Real[3] Command GetWaypoint(String planID,Integer index);
Boolean[2] Command CheckFenceViolation(Real Position[3],Real Velocity[3]);
Real[3] Command GetRecoveryPosition(Real Position[3]);
Command pprint(...);

CONFLICT_MANAGEMENT:
{
    Integer _numMissionWP;
    Real acPosition[3];
    Real acVelocity[3];
    Boolean fenceConflict[2];
    Boolean trafficConflict = false;
    Boolean flightPlanConflict = false;
    Boolean resolutionActive = false;
    Real newConflictHash = 0;
    Real oldConflictHash = 0;
    Integer _currentM_WP = 0;
    Integer _currentR_WP = 0;
    
    _numMissionWP = Lookup(numMissionWP);

    pprint("starting CONFLICT_MANAGEMENT");

    pprint("numMissionWP:",_numMissionWP);


    CORE:Concurrence{
    
	DETECTION:
	{
	    Integer numFenceConflicts;
	    Boolean statusGF[2];
	    Boolean statusTF;
	    Boolean statusFP;
	
	    //Repeat true;

	    
	    acPosition = Lookup(position);
	    
	    acVelocity = Lookup(velocity);

	    pprint("position:",acPosition[0],acPosition[1],acPosition[2]);
	    pprint("velocity:",acVelocity[0],acVelocity[1],acVelocity[2]);

	    /*
	      FENCE: {
	      EndCondition isKnown(statusGF);
	      statusGF = CheckFenceViolation(acPosition,acVelocity);
	      }*/

	
	    //pprint("conflict:",statusGF[0],statusGF[1]);
	
	    /*
	      TRAFFIC:{
	      EndCondition isKnown(statusTF);
	      statusTF = CheckTrafficViolation(acPosition);
	      }
	
	      FLIGHTPLAN: {
	      EndCondition isKnown(statusFP);
	      if(resolutionActive){
	      _currentR_WP = Lookup(currentResolutionWP);
	      statusFP = CheckFlightPlanConflict(acPosition,_currentR_WP);
	      }
	      else{
	      _currentM_WP = Lookup(currentMissionWP)
	      statusFP = CheckFlightPlanConflict(acPosition,_currentM_WP);    
	      }
	      endif	    
	      }*/

	    fenceConflict = statusGF;
	    //trafficConflict = statusTF;
	    //flightPlanConflict = statusFP;

	    if(fenceConflict[0] || fenceConflict[1]){
		pprint("Detected geofence conflict\n");
	    }endif
		 }

	
	RESOLUTION:{

	    Real RecoveryPosition[3];
	    Boolean resolutionCompleted;
	    Repeat true;
	
	    COMPUTE_SOLUTION:{
	    
		KEEP_IN:{
		    StartCondition fenceConflict[0];
		    SkipCondition !fenceConflict[0];

		    pprint("Obtaining recovery point");
		
		    {	    
			EndCondition isKnown(RecoveryPosition[0]);
			RecoveryPosition = GetRecoveryPosition(acPosition);
		    }

		}

		/*
		  KEEP_OUT:{
		  SkipCondition !fenceConflict[1];

		  }

		  TRAFFIC:{


		  }

		  FLIGHTPLAN_DEV:{


		  }
		*/
	    }

	    EXECUTE_RESOLUTION:{
		FENCE_RESOLUTION:{
		    SkipCondition !fenceConflict[0];
		    LibraryCall GOTO_POSITION(TargetPosition = RecoveryPosition);
		}
	    }

	    RESUME_MISSION:{
		Boolean validPoint = false;
		StartCondition resolutionCompleted;
	    
		while(!validPoint && _currentM_WP < _numMissionWP){
		    Real _position[3];
		    Real _velocity[3];
		    Boolean status[2];

		    _velocity[0] = 0.0;
		    _velocity[1] = 0.0;
		    _velocity[2] = 0.0;
		
		    {		    
			EndCondition isKnown(_position);
			_position = GetWaypoint("Plan1",_currentM_WP);		
		    }

		    {
			EndCondition isKnown(status[0]);
			status = CheckFenceViolation(_position,_velocity);
		    }
		    
		    if(status[0] || status[1]){
			_currentM_WP = _currentM_WP + 1;
		    }else{
			validPoint = true;
			LibraryCall GOTO_POSITION(TargetPosition = _position);
		    }endif
			 
			 }	    
	    }
	    
	}
    }
}
